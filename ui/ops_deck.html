<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Ops Deck</title>
  <style>
    :root {
      --bg: #0c0f18;
      --panel: #111629;
      --card: #141b2f;
      --border: #1f2942;
      --accent: #7cd2ff;
      --accent-2: #ffb36b;
      --text: #e6edf7;
      --muted: #9ea7be;
      --green: #7ee0a3;
      --red: #ff7b7b;
      --blue: #79a6ff;
      --yellow: #ffe38f;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, rgba(124, 210, 255, 0.08), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(255, 179, 107, 0.08), transparent 40%),
        linear-gradient(180deg, #0b0f18, #0a0d14 40%, #080b12);
      color: var(--text);
      font: 14px/1.4 "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(13, 17, 28, 0.85);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.4px;
    }

    #app {
      display: grid;
      grid-template-columns: minmax(580px, 1fr) 360px;
      gap: 16px;
      padding: 14px;
      flex: 1;
      min-height: 0;
      align-items: start;
    }

    @media (max-width: 1100px) {
      #app {
        grid-template-columns: 1fr;
      }

      #control-panel {
        width: 100%;
        max-width: 100%;
      }
    }

    .surface {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.28);
    }

    #canvas-wrapper {
      position: relative;
      min-height: 560px;
      max-height: calc(100vh - 140px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #main-canvas {
      width: 100%;
      height: min(78vh, 820px);
      min-height: 500px;
      max-height: calc(100vh - 170px);
      border-radius: 12px;
      border: 1px solid var(--border);
      background: radial-gradient(circle at 40% 20%, rgba(124, 210, 255, 0.05), transparent 45%),
        linear-gradient(180deg, #0f1420, #0b101a 55%, #0b0f17);
      display: block;
    }

    .panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
      min-width: 340px;
      width: 360px;
      max-width: 380px;
    }

    .toolbar,
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .toolbar .spacer {
      flex: 1;
    }

    .pill {
      padding: 6px 12px;
      border-radius: 999px;
      background: #0f1421;
      border: 1px solid var(--border);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
    }

    .pill.dot::before {
      content: "‚óè";
      display: inline-block;
      font-size: 10px;
    }

    .pill.good {
      color: var(--green);
      border-color: rgba(126, 224, 163, 0.5);
    }

    .pill.bad {
      color: var(--red);
      border-color: rgba(255, 123, 123, 0.5);
    }

    .pill.warn {
      color: var(--yellow);
      border-color: rgba(255, 227, 143, 0.45);
    }

    .pill.clickable {
      cursor: pointer;
      transition: border-color 0.2s, color 0.2s, box-shadow 0.2s;
    }

    .pill.clickable:hover {
      border-color: var(--accent);
      color: var(--text);
      box-shadow: 0 0 0 1px rgba(124, 210, 255, 0.25);
    }

    .btn {
      appearance: none;
      background: #1b2235;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      transition: border-color 0.15s, transform 0.08s, background 0.2s;
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      border-color: var(--border);
      transform: none;
    }

    .btn:hover {
      border-color: var(--accent);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn.primary {
      background: linear-gradient(180deg, #2b3954, #1f2a41);
      border-color: #39486b;
    }

    .btn.success {
      background: linear-gradient(180deg, #1f3a2a, #1a2f22);
      border-color: #2f5c3f;
      color: var(--green);
    }

    .btn.ghost {
      background: transparent;
      color: var(--muted);
    }

    .btn.danger {
      border-color: rgba(255, 123, 123, 0.6);
      color: var(--red);
    }

    .btn-group {
      display: inline-flex;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .btn-group button {
      border: none;
      border-right: 1px solid var(--border);
      background: #1b2235;
    }

    .btn-group button:last-child {
      border-right: none;
    }

    .card-title {
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .stack {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }

    .tile {
      background: #111829;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      min-height: 74px;
    }

    .tile strong {
      display: block;
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 4px;
    }

    input,
    select,
    textarea {
      background: #0f1422;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      font: inherit;
    }

    textarea {
      width: 100%;
      min-height: 90px;
      resize: vertical;
    }

    input[type="range"] {
      accent-color: var(--accent);
    }

    .drop-zone {
      border: 1px dashed var(--border);
      border-radius: 14px;
      padding: 14px;
      color: var(--muted);
      background: linear-gradient(180deg, rgba(20, 26, 40, 0.85), rgba(13, 18, 32, 0.9));
      cursor: pointer;
      transition: border-color 0.2s, color 0.2s, background 0.25s;
    }

    .drop-zone.drag {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(124, 210, 255, 0.07);
    }

    .upload-empty {
      text-align: center;
      opacity: 0.9;
    }

    .upload-loaded {
      display: none;
      align-items: center;
      gap: 10px;
      justify-content: space-between;
    }

    .upload-chip {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
    }

    .type-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid var(--border);
      flex-shrink: 0;
    }

    .type-dot.scenario {
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(124, 210, 255, 0.12);
    }

    .type-dot.recording {
      background: var(--accent-2);
      box-shadow: 0 0 0 4px rgba(255, 179, 107, 0.12);
    }

    .upload-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .upload-name {
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .upload-detail {
      color: var(--muted);
      font-size: 13px;
    }

    .icon-btn {
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
      width: 26px;
      height: 26px;
      border-radius: 8px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
    }

    .icon-btn:hover {
      color: var(--text);
      border-color: var(--accent);
    }

    #meta-json,
    #actions-json,
    #info-json {
      background: #0f1422;
      border-radius: 10px;
      padding: 8px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 12px;
      max-height: 240px;
      overflow: auto;
      border: 1px solid var(--border);
    }

    .label {
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .flex-between {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 8px;
      background: #0f1421;
      border: 1px solid var(--border);
      color: var(--muted);
      font-weight: 700;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .modal.open {
      display: flex;
    }

    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(8, 10, 16, 0.8);
      backdrop-filter: blur(6px);
    }

    .modal-card {
      position: relative;
      width: min(900px, 92vw);
      max-height: 86vh;
      background: #0f1420;
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1;
    }

    .modal-card textarea {
      min-height: 320px;
      max-height: 56vh;
      width: 100%;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 12px;
      background: #0b1020;
    }

    .modal-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    details.collapsible {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #0f1421;
    }

    details.collapsible summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      color: var(--muted);
      font-weight: 700;
    }

    details.collapsible summary::-webkit-details-marker {
      display: none;
    }

    .summary-actions {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .pill-btn {
      border: 1px solid var(--border);
      background: #1b2235;
      color: var(--text);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }

    .detail-row {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0f1421;
      margin-bottom: 8px;
    }

    .detail-row .label {
      display: block;
      margin-bottom: 4px;
    }

    .entity-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
      margin-top: 6px;
    }

    .entity-chip {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      background: #0f1421;
    }

    .entity-chip .label {
      margin: 0 0 4px 0;
    }

    .entity-action {
      margin-top: 10px;
      border: 1px dashed var(--border);
      border-radius: 10px;
      padding: 10px;
      background: rgba(124, 210, 255, 0.04);
    }

    /* Welcome Modal Styles */
    .welcome-content {
      width: min(800px, 100vw);
      max-width: 100%;
      text-align: center;
    }

    .welcome-content h2 {
      color: var(--accent);
      font-size: clamp(18px, 3vw, 24px);
      margin: 0 0 14px 0;
    }

    .welcome-content .welcome-subtitle {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 0;
      line-height: 1.4;
    }

    .rules-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
      text-align: left;
      margin: 14px 0 10px;
    }

    .rule-card {
      background: rgba(124, 210, 255, 0.06);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
    }

    .rule-card h4 {
      color: var(--accent);
      margin: 0 0 6px 0;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .rule-card ul {
      margin: 0;
      padding-left: 16px;
      color: var(--muted);
      font-size: 11px;
      list-style: disc;
    }

    .rule-card li {
      margin: 3px 0;
    }

    .game-rules-box {
      margin-top: 10px;
      padding: 10px 14px;
      background: rgba(124, 210, 255, 0.05);
      border-radius: 8px;
      border-left: 3px solid #7cd2ff;
      text-align: left;
    }

    .game-rules-box h3 {
      margin: 0 0 6px 0;
      font-size: 13px;
      color: #7cd2ff;
    }

    .game-rules-box ul {
      margin: 0;
      padding-left: 18px;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text);
      list-style: disc;
    }

    .game-rules-box li {
      margin: 2px 0;
    }

    /* Human Action Panel */
    .action-panel {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #1a2235, #141b2f);
      border: 2px solid var(--accent);
      border-radius: 14px;
      padding: 14px 18px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(124, 210, 255, 0.15);
      z-index: 40;
      display: none;
      min-width: 320px;
      max-width: 500px;
    }

    .action-panel.visible {
      display: block;
    }

    .action-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    .action-panel-title {
      font-weight: 700;
      color: var(--accent);
    }

    .action-entity-type {
      font-size: 11px;
      color: var(--muted);
      margin-left: 6px;
    }

    .pending-actions-section {
      margin-top: 10px;
      border-top: 1px solid var(--border);
      padding-top: 8px;
    }

    .pending-actions-title {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .pending-action {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      background: rgba(126, 224, 163, 0.1);
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 12px;
    }

    .pending-action .entity-id {
      color: var(--accent);
      font-weight: 600;
    }

    .pending-action .action-label {
      color: var(--green);
    }

    .no-pending {
      color: var(--muted);
      font-size: 11px;
      font-style: italic;
    }

    .action-panel-close {
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      font-size: 18px;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .action-btn {
      padding: 8px 14px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #1b2235;
      color: var(--text);
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.15s;
    }

    .action-btn:hover {
      border-color: var(--accent);
      background: rgba(124, 210, 255, 0.1);
    }

    .action-btn.selected {
      border-color: #7cd2ff;
      background: rgba(124, 210, 255, 0.15);
      color: #7cd2ff;
    }

    .action-btn.move {
      border-left: 3px solid var(--blue);
    }

    .action-btn.shoot {
      border-left: 3px solid var(--red);
    }

    .action-btn.toggle {
      border-left: 3px solid var(--yellow);
    }

    .action-btn.wait {
      border-left: 3px solid var(--muted);
    }

    /* Human Turn Indicator */
    .turn-indicator {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #1a2f3a, #162735);
      border: 2px solid #7cd2ff;
      border-radius: 10px;
      padding: 10px 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      z-index: 35;
      display: none;
      text-align: center;
    }

    .turn-indicator.visible {
      display: block;
    }

    .turn-indicator-text {
      color: var(--green);
      font-weight: 700;
      font-size: 14px;
    }

    .turn-indicator-hint {
      color: var(--muted);
      font-size: 11px;
      margin-top: 4px;
    }

    /* Pending Actions List */
    .pending-actions {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    .pending-action-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      background: rgba(126, 224, 163, 0.08);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .pending-action-entity {
      color: var(--accent);
      font-weight: 600;
    }

    .pending-action-action {
      color: var(--green);
    }

    .entity-selectable {
      cursor: pointer;
    }

    .entity-highlight {
      animation: pulse-highlight 1.5s infinite;
    }

    @keyframes pulse-highlight {

      0%,
      100% {
        filter: drop-shadow(0 0 8px rgba(124, 210, 255, 0.6));
      }

      50% {
        filter: drop-shadow(0 0 16px rgba(124, 210, 255, 0.9));
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>Ops Deck</h1>
    <div class="row" style="gap:6px;">
      <label class="label" for="backend-url">Backend</label>
      <input id="backend-url" type="text" value="http://localhost:8000" style="width: 220px;">
      <span id="connection-status" class="pill dot warn clickable">Checking...</span>
      <span class="pill" id="mode-pill">Idle</span>
    </div>
    <div class="row" style="gap:8px;">
      <button class="btn success" id="start-btn" disabled>‚ñ∂ Launch Scenario</button>
      <button class="btn" id="fork-btn" title="Start a new live run from the selected frame" disabled>‚ßâ Fork</button>
    </div>
    <div class="spacer"></div>
    <button class="btn" id="export-btn" disabled title="No frames to export">‚¨á Export</button>
  </header>

  <div id="app">
    <div class="surface" id="canvas-wrapper">
      <div class="flex-between">
        <div class="row">
          <button id="play-toggle-btn" class="btn primary">‚ñ∂ Play</button>
          <button id="step-btn" class="btn">‚è≠ Step</button>
          <!-- Human Turn Controls -->
          <button id="next-turn-btn" class="btn success" style="display:none; margin-left:16px;">‚û°Ô∏è Next Turn</button>
          <span id="human-turn-status" class="pill" style="display:none; background: #22c55e; color: white;">Your Turn
            (BLUE)</span>
        </div>
        <div class="row">
          <label class="label">View</label>
          <select id="view-select">
            <option value="god">Admin</option>
            <option value="blue">Blue</option>
            <option value="red">Red</option>
          </select>
          <label class="row" style="gap:4px;">
            <input id="toggle-actions" type="checkbox">
            <span class="label">Actions</span>
          </label>
          <label class="row" style="gap:4px;">
            <input id="toggle-dead-entities" type="checkbox" checked>
            <span class="label">Dead</span>
          </label>
          <label class="row" style="gap:4px;">
            <input id="toggle-radar" type="checkbox">
            <span class="label">Radar</span>
          </label>
          <label class="row" style="gap:4px;">
            <input id="toggle-ids" type="checkbox" checked>
            <span class="label">IDs</span>
          </label>
          <label class="row" style="gap:4px;">
            <input id="toggle-grid-labels" type="checkbox">
            <span class="label">Coords</span>
          </label>
        </div>
        <div class="row">
          <label class="label">Timeline</label>
          <input id="timeline" type="range" min="0" max="0" value="0" style="width:220px;">
          <span class="pill" id="timeline-label">0 / 0</span>
        </div>
      </div>
      <canvas id="main-canvas" width="900" height="520"></canvas>
      <div class="row" style="display: none;">
        <div class="pill" id="winner-pill">Victory: ‚Äî</div>
        <div class="pill" id="tracking-pill">Tracking: ‚Äî</div>
        <div class="pill" id="entity-pill">Entities: ‚Äî</div>
      </div>
    </div>

    <div class="panel" id="control-panel">
      <div class="surface">
        <div class="card-title">Load Scenario / Recording</div>
        <div>
          <div class="drop-zone" id="upload-drop">
            <div class="upload-empty" id="upload-empty">Drop scenario or recording JSON</div>
            <div class="upload-loaded" id="upload-loaded">
              <div class="upload-chip">
                <span class="type-dot" id="upload-type-dot" title="Upload type"></span>
                <div class="upload-meta">
                  <button class="upload-name" id="upload-summary" type="button"></button>
                  <div class="upload-detail" id="upload-detail-text"></div>
                </div>
              </div>
              <button class="icon-btn" id="upload-clear-btn" aria-label="Clear upload">√ó</button>
            </div>
          </div>
          <input type="file" id="upload-file" accept=".json" style="display:none">
          <div style="margin-top: 10px; text-align: center;">
            <button class="btn primary" id="use-default-scenario-btn" style="width: 100%;">
              Use Default Scenario (Human vs LLM Agent)
            </button>
          </div>
        </div>
      </div>



      <!-- Your Actions Panel (visible during human turn) -->
      <div class="surface" id="your-actions-panel" style="display: none;">
        <div class="card-title" style="display: flex; justify-content: space-between; align-items: center;">
          <span>Your Actions</span>
          <div style="display:flex; gap:6px; align-items:center;">
            <span id="turn-counter-pill" class="pill" style="font-size: 10px;">Turn 0</span>
            <span class="pill" style="font-size: 10px; background: #3b82f6;">BLUE</span>
          </div>
        </div>
        <div id="force-summary" style="font-size: 10px; color: var(--muted); padding: 4px 8px; margin-bottom: 6px;">
        </div>
        <div id="entity-actions-list" style="font-size: 12px; max-height: 350px; overflow-y: auto;">
          <!-- Entity action rows will be populated here -->
        </div>
        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid var(--border);">
          <button id="submit-actions-btn" class="btn success" style="width: 100%; position: relative;">
            <span id="submit-btn-text">Submit Actions & End Turn</span>
            <span id="submit-btn-spinner" style="display:none; position:absolute; right:12px;">...</span>
          </button>
        </div>
      </div>

      <div class="surface" id="strategic-status-panel">
        <div class="card-title" style="font-weight: 700; font-size: 14px;">LLM Agent Reasoning</div>
        <div id="strategic-content" style="font-size: 12px;">
          <!-- Combat Log - MOVED TO TOP -->
          <details class="collapsible" open style="margin-bottom: 6px;">
            <summary><span class="label">Combat Log</span></summary>
            <div id="combat-log-list" style="padding: 6px 0; color: var(--text); font-size: 11px;">--</div>
            <div
              style="padding: 4px 8px; margin-top: 4px; background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; border-radius: 3px; font-size: 10px; color: #ef4444;">
              Shots with probability <25% will always <strong>MISS</strong>
            </div>
          </details>
          <!-- Situation -->
          <div class="detail-row" style="margin-bottom: 6px; padding: 6px 8px;">
            <span class="label" style="font-size: 12px; font-weight: 400; color: var(--text);">Situation
              Assessment</span>
            <div id="situation-display" style="color: var(--text); margin-top: 2px; font-size: 11px; line-height: 1.4;">
              --</div>
          </div>
          <!-- Formation & Momentum pills -->
          <div class="row" style="gap: 6px; margin-bottom: 8px; flex-wrap: wrap;">
            <div class="pill" id="enemy-formation-pill" style="font-size: 11px;" title="Inferred enemy formation">
              Formation: --</div>
            <div class="pill" id="momentum-pill" style="font-size: 11px;" title="Momentum indicator">Momentum: --</div>
          </div>
          <!-- Force Composition - Hidden -->
          <details class="collapsible" style="margin-bottom: 6px; display: none;">
            <summary><span class="label">Force Composition</span></summary>
            <div id="force-composition" style="padding: 6px 0; color: var(--muted); font-size: 11px;">--</div>
          </details>
          <!-- Priorities & Directives -->
          <details class="collapsible" open style="margin-bottom: 6px;">
            <summary><span class="label">Priorities & Directives</span></summary>
            <div id="priorities-list" style="padding: 6px 0; color: var(--muted); font-size: 11px;">--</div>
          </details>
          <!-- Unit Reasoning -->
          <details class="collapsible" open style="margin-bottom: 6px;">
            <summary><span class="label">Unit Tactical Reasoning</span></summary>
            <div id="unit-decisions-list" style="padding: 6px 0; max-height: 200px; overflow-y: auto; font-size: 11px;">
              --</div>
          </details>
        </div>
      </div>

      <!-- Loop Controls - Moved below LLM Agent Reasoning -->
      <div class="surface">
        <div class="card-title">Loop Controls</div>
        <div class="row" style="gap:10px; align-items: center;">
          <span class="label">Injections</span>
          <button class="pill clickable" id="injection-status" type="button">No pending injection</button>
        </div>
      </div>

      <!-- Frame Details removed: JSON panels (Actions/Metadata/Info) not needed in production UI -->
    </div>
  </div>

  <div class="modal" id="scenario-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <div class="flex-between">
        <div>
          <div class="label" id="scenario-modal-label">Scenario JSON</div>
          <div class="tag" id="scenario-modal-meta">‚Äî</div>
        </div>
        <button class="btn ghost" id="scenario-modal-close">Close</button>
      </div>
      <textarea id="scenario-modal-editor" spellcheck="false"></textarea>
      <div class="modal-actions">
        <span class="pill warn" id="scenario-modal-status">Ready to edit</span>
        <button class="btn primary" id="scenario-modal-save">Save changes</button>
      </div>
    </div>
  </div>

  <div class="modal" id="injection-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <div class="flex-between">
        <div>
          <div class="label">Injection JSON</div>
          <div class="tag">Template: { "blue": {‚Ä¶}, "red": {‚Ä¶} }</div>
        </div>
        <button class="btn ghost" id="injection-modal-close">Close</button>
      </div>
      <textarea id="injection-modal-editor" spellcheck="false"></textarea>
      <div class="row" style="gap:14px; align-items:center;">
        <label class="row" style="gap:6px;">
          <input type="radio" name="injection-mode" value="once" checked>
          <span class="label">Apply once (next step)</span>
        </label>
        <label class="row" style="gap:6px;">
          <input type="radio" name="injection-mode" value="persistent">
          <span class="label">Apply every step</span>
        </label>
      </div>
      <div class="modal-actions">
        <button class="btn primary" id="apply-injection-btn">Apply</button>
        <button class="btn ghost" id="clear-injection-btn">Clear</button>
        <span class="pill warn" id="injection-modal-status">Not applied</span>
      </div>
    </div>
  </div>

  <div class="modal" id="frame-detail-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <div class="flex-between">
        <div>
          <div class="label" id="frame-modal-label">Frame detail</div>
          <div class="tag" id="frame-modal-meta">Read only</div>
        </div>
        <button class="btn ghost" id="frame-modal-close">Close</button>
      </div>
      <textarea id="frame-modal-editor" spellcheck="false" readonly></textarea>
    </div>
  </div>

  <div class="modal" id="entity-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <div class="flex-between">
        <div>
          <div class="label">Entity details</div>
          <div class="tag" id="entity-modal-title">‚Äî</div>
        </div>
        <button class="btn ghost" id="entity-modal-close">Close</button>
      </div>
      <div id="entity-modal-body"></div>
    </div>
  </div>

  <!-- Welcome Modal -->
  <div class="modal open" id="welcome-modal">
    <div class="modal-backdrop"></div>
    <div class="modal-card welcome-content">
      <h2>Welcome to 2D War Game </h2>
      <p class="welcome-subtitle">Simulation combat game for AI agents </p>
      <div class="modal-actions" style="justify-content: center; margin-bottom: 14px;">
        <button class="btn success" id="welcome-start-btn"
          style="padding: 10px 40px; font-size: 15px; font-weight: 700; letter-spacing: 0.5px;">
          &#9658; Start Game
        </button>
      </div>

      <div class="rules-grid">
        <div class="rule-card">
          <h4> Aircraft (Fighter)</h4>
          <ul>
            <li><strong>WAIT</strong> - Hold position</li>
            <li><strong>MOVE</strong> - Up, Down, Left, Right</li>
            <li><strong>SHOOT</strong> - Attack visible enemies</li>
          </ul>
        </div>
        <div class="rule-card">
          <h4> SAM (Surface-to-Air Missile)</h4>
          <ul>
            <li><strong>WAIT</strong> - Hold position</li>
            <li><strong>TOGGLE</strong> - Radar On/Off</li>
            <li><strong>SHOOT</strong> - When radar ON</li>
          </ul>
        </div>
        <div class="rule-card">
          <h4> AWACS (Warning &amp; Control)</h4>
          <ul>
            <li><strong>WAIT</strong> - Hold position</li>
            <li><strong>MOVE</strong> - Up, Down, Left, Right</li>
            <li>No weapons (recon only)</li>
          </ul>
        </div>
        <div class="rule-card">
          <h4> Decoy</h4>
          <ul>
            <li><strong>WAIT</strong> - Hold position</li>
            <li><strong>MOVE</strong> - Up, Down, Left, Right</li>
            <li>Looks like aircraft to enemies</li>
          </ul>
        </div>
      </div>

      <div class="game-rules-box">
        <h3> Game Rules</h3>
        <ul>
          <li><strong>You control BLUE</strong> vs RED (LLM Agent opponent)</li>
          <li>Load the scenario, then click <strong>&#9658; Launch Scenario</strong></li>
          <li>One action per unit per turn -> select from the sidebar</li>
          <li>Shots with &lt;25% probability will <strong>MISS</strong></li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Turn Indicator -->
  <div class="turn-indicator" id="turn-indicator">
    <div class="turn-indicator-text"> Your Turn (BLUE)</div>
    <div class="turn-indicator-hint">Select Actions of units from the list</div>
  </div>

  <!-- Action Selection Panel -->
  <div class="action-panel" id="action-panel">
    <div class="action-panel-header">
      <div>
        <span class="action-panel-title" id="action-entity-name">Select Entity</span>
        <span class="action-entity-type" id="action-entity-type"></span>
      </div>
      <button class="action-panel-close" id="action-panel-close">√ó</button>
    </div>
    <div class="action-buttons" id="actions-grid"></div>
    <div class="pending-actions-section">
      <div class="pending-actions-title">Pending Actions:</div>
      <div class="pending-actions" id="pending-actions-list"></div>
    </div>
    <div style="margin-top: 12px; display: flex; gap: 8px; justify-content: flex-end;">
      <button class="btn" id="clear-actions-btn">Clear All</button>
      <button class="btn success" id="end-turn-btn">‚úì End Turn</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("main-canvas");
    const ctx = canvas.getContext("2d");

    const state = {
      baseUrl: document.getElementById("backend-url").value.trim(),
      connected: false,
      mode: "idle", // idle | live | replay
      scenario: null,
      recordingScenario: null,
      frames: [],
      currentIndex: 0,
      playing: false,
      playTimer: null,
      speed: 1,
      pendingInjection: null,
      showActions: false,
      showRadar: false,
      showIds: true,
      showDeadEntities: true,
      showGridCoords: false,
      view: "god",
      scenarioName: null,
      recordingName: null,
      injectionMode: "once",
      victoryInfo: null,
      uploadInfo: null,
      startingRun: false,
      // Human vs Agent state
      isHumanTurn: false,
      humanTeam: "BLUE",
      selectedEntityId: null,
      pendingHumanActions: {}, // { entityId: actionData }
      availableActionsCache: {}, // { entityId: actionsArray }
    };

    // ----------- Human Turn Management -----------
    function isHumanVsAgentGame() {
      if (!state.scenario || !state.scenario.agents) return false;
      return state.scenario.agents.some(a => a.type === "human");
    }

    function getHumanTeam() {
      if (!state.scenario || !state.scenario.agents) return "BLUE";
      const humanAgent = state.scenario.agents.find(a => a.type === "human");
      return humanAgent ? humanAgent.team : "BLUE";
    }

    function showTurnIndicator(show) {
      const indicator = document.getElementById("turn-indicator");
      if (indicator) {
        indicator.classList.toggle("visible", show);
      }
    }

    function showActionPanel(show) {
      const panel = document.getElementById("action-panel");
      if (panel) {
        panel.classList.toggle("visible", show);
      }
    }

    function updatePendingActionsList() {
      const listEl = document.getElementById("pending-actions-list");
      if (!listEl) return;

      const entries = Object.entries(state.pendingHumanActions);
      if (entries.length === 0) {
        listEl.innerHTML = '<div style="color: var(--muted); font-size: 11px;">No actions selected yet</div>';
        return;
      }

      listEl.innerHTML = entries.map(([entityId, actionData]) => {
        const label = actionData.label || actionData.type || "Unknown";
        return `<div class="pending-action-item">
          <span class="pending-action-entity">#${entityId}</span>
          <span class="pending-action-action">${label}</span>
        </div>`;
      }).join("");
    }

    async function fetchAllowedActions(entityId) {
      try {
        const data = await fetchJson(`/allowed-actions/${entityId}`);
        state.availableActionsCache[entityId] = data;
        return data;
      } catch (err) {
        console.error("Failed to fetch allowed actions:", err);
        return null;
      }
    }

    function renderActionButtons(entityData) {
      const container = document.getElementById("action-buttons");
      if (!container || !entityData) return;

      const actions = entityData.actions || [];
      const entityId = entityData.entity_id;
      const currentAction = state.pendingHumanActions[entityId];

      container.innerHTML = actions.map((action, idx) => {
        const type = (action.type || "").toLowerCase();
        let cssClass = "action-btn";
        if (type === "move") cssClass += " move";
        else if (type === "shoot") cssClass += " shoot";
        else if (type === "toggle") cssClass += " toggle";
        else if (type === "wait") cssClass += " wait";

        const isSelected = currentAction &&
          currentAction.type === action.type &&
          JSON.stringify(currentAction.params) === JSON.stringify(action.params);
        if (isSelected) cssClass += " selected";

        return `<button class="${cssClass}" data-action-idx="${idx}">${action.label || action.type}</button>`;
      }).join("");

      // Add event listeners
      container.querySelectorAll(".action-btn").forEach((btn, idx) => {
        btn.addEventListener("click", () => {
          const action = actions[idx];
          state.pendingHumanActions[entityId] = action;
          renderActionButtons(entityData); // Re-render to show selection
          updatePendingActionsList();
        });
      });
    }

    async function openActionPanelForEntity(entityId) {
      state.selectedEntityId = entityId;
      const entityData = await fetchAllowedActions(entityId);
      if (!entityData || !entityData.alive) {
        alert("This entity cannot take actions.");
        return;
      }

      const title = document.getElementById("action-panel-title");
      if (title) {
        title.textContent = `${entityData.entity_kind.toUpperCase()} #${entityId} - ${entityData.entity_name || ""}`;
      }

      renderActionButtons(entityData);
      updatePendingActionsList();
      showActionPanel(true);
    }

    async function endHumanTurn() {
      if (!state.isHumanTurn) return;

      // Build injection with human actions
      const humanTeam = getHumanTeam().toLowerCase();
      const injections = {
        [humanTeam]: {
          actions: state.pendingHumanActions
        }
      };

      console.log("üîµ [TURN END] Human submitting actions:", {
        team: humanTeam,
        currentFrame: state.currentIndex,
        actions: Object.keys(injections[humanTeam].actions).length,
        actionDetails: injections
      });

      state.isHumanTurn = false;
      showTurnIndicator(false);
      showActionPanel(false);
      state.pendingHumanActions = {};
      state.availableActionsCache = {};
      state.selectedEntityId = null;

      // Show loading state on submit button
      const submitBtn = document.getElementById("submit-actions-btn");
      const btnText = document.getElementById("submit-btn-text");
      const btnSpinner = document.getElementById("submit-btn-spinner");
      if (submitBtn) submitBtn.disabled = true;
      if (btnText) btnText.textContent = "AI Thinking...";
      if (btnSpinner) btnSpinner.style.display = "inline";

      try {
        console.log("‚öôÔ∏è [STEP] Executing stepLive with human actions...");
        // Execute step with injected actions via stepLive
        state.pendingInjection = injections;
        await stepLive();
        state.pendingInjection = null;
        console.log("‚úÖ [STEP] stepLive completed. New frame index:", state.currentIndex);

        // Update strategic status from AI metadata
        const stepFrame = state.frames[state.currentIndex];
        if (stepFrame && stepFrame.action_metadata) {
          const aiTeam = humanTeam === "blue" ? "red" : "blue";
          const aiMeta = stepFrame.action_metadata?.[aiTeam] || null;
          updateStrategicStatus(aiMeta, stepFrame.step_info);
        }

        // Check if game is over
        const frame = state.frames[state.currentIndex];
        if (!isFrameDone(frame) && isHumanVsAgentGame()) {
          startHumanTurn();
        }
      } catch (err) {
        console.error("Failed to execute turn:", err);
        alert("Error: " + err.message);
        state.isHumanTurn = true;
        showTurnIndicator(true);
      } finally {
        // Reset submit button state
        if (submitBtn) submitBtn.disabled = false;
        if (btnText) btnText.textContent = "Submit Actions & End Turn";
        if (btnSpinner) btnSpinner.style.display = "none";
      }
    }

    async function startHumanTurn() {
      if (!isHumanVsAgentGame()) return;

      console.log(" [TURN START] Human turn beginning:", {
        currentFrame: state.currentIndex,
        humanTeam: getHumanTeam(),
        totalFrames: state.frames.length
      });

      state.isHumanTurn = true;
      state.humanTeam = getHumanTeam();
      state.pendingHumanActions = {};
      state.availableActionsCache = {};
      state.selectedEntityId = null;

      // Update turn counter
      const turnPill = document.getElementById("turn-counter-pill");
      const frame = state.frames[state.currentIndex];
      if (turnPill && frame) {
        turnPill.textContent = `Turn ${frame.turn || state.frames.length}`;
      }

      showTurnIndicator(true);
      showYourActionsPanel(true);
      setPlaying(false);
      drawCurrent();

      // Populate entity actions using allowed actions from current-world
      await populateEntityActionsList();
    }

    function closeWelcomeModal() {
      document.getElementById("welcome-modal").classList.remove("open");
    }

    async function loadDefaultScenario() {
      try {
        const scenario = await fetchJson("/default-scenario");
        state.scenario = scenario;
        state.scenarioName = "Default Scenario (Human vs AI)";
        state.uploadInfo = {
          kind: "scenario",
          name: state.scenarioName,
          detail: summarizeScenario(scenario),
        };
        updateStartButton();
        updateExportButton();
        updateUploadSummary();
        updateForkButton();
      } catch (err) {
        console.error("Failed to load default scenario:", err);
        alert("Failed to load default scenario: " + err.message);
      }
    }

    function isFrameDone(frame) {
      if (!frame) return false;
      if (frame.done === true) return true;
      return !!(frame.world && frame.world.game_over);
    }

    // ----------- Utilities -----------
    function setStatus(el, text, variant) {
      el.textContent = text;
      el.classList.remove("good", "bad", "warn");
      if (variant) el.classList.add(variant);
    }

    async function fetchJson(path, options = {}) {
      const url = `${state.baseUrl}${path}`;
      const res = await fetch(url, { headers: { "Content-Type": "application/json" }, ...options });
      if (!res.ok) {
        const body = await res.text();
        throw new Error(`HTTP ${res.status}: ${body}`);
      }
      return res.json();
    }

    function summarizeScenario(scenario) {
      if (!scenario) return "No scenario loaded.";
      const cfg = scenario.config || {};
      const entities = (scenario.entities || []).length;
      const agents = (scenario.agents || []).length;
      return `Grid ${cfg.grid_width || "?"}x${cfg.grid_height || "?"}, ${entities} entities, ${agents} agents`;
    }

    function setPlaying(isPlaying) {
      state.playing = isPlaying;
      if (!isPlaying) clearTimeout(state.playTimer);
      updatePlayButton();
    }

    function updatePlayButton() {
      const btn = document.getElementById("play-toggle-btn");
      if (!btn) return;
      btn.textContent = state.playing ? "‚è∏ Pause" : "‚ñ∂ Play";
      btn.classList.toggle("primary", !state.playing);
    }

    function updateStartButton() {
      const btn = document.getElementById("start-btn");
      if (!btn) return;
      const hasScenario = !!state.scenario;
      const restarting = state.mode === "live" && hasScenario;
      const starting = state.startingRun;
      btn.disabled = !hasScenario || starting;
      if (starting) {
        btn.textContent = "‚Ä¶ Starting";
        btn.title = "Launching run...";
      } else {
        btn.textContent = restarting ? "‚ü≥ Re-launch Scenario" : "‚ñ∂ Launch Scenario";
        btn.title = hasScenario ? "Start a new live run with the loaded scenario" : "Load a scenario to start";
      }
    }

    function updateForkButton() {
      const btn = document.getElementById("fork-btn");
      if (!btn) return;
      const hasScenario = !!state.scenario;
      const hasFrames = state.frames.length > 0;
      const starting = state.startingRun;
      btn.disabled = !(hasScenario && hasFrames) || starting;
      if (starting) {
        btn.title = "Launching run...";
      } else if (!hasFrames) {
        btn.title = "Load or play to get frames first";
      } else if (!hasScenario) {
        btn.title = "Load a scenario to fork";
      } else {
        btn.title = "Start a new live run from the selected frame";
      }
    }

    function setStartingRun(isStarting) {
      state.startingRun = isStarting;
      updateStartButton();
      updateForkButton();
    }

    function updateExportButton() {
      const btn = document.getElementById("export-btn");
      if (!btn) return;
      const hasFrames = state.frames.length > 0;
      const hasScenario = !!state.scenario;
      const enabled = hasFrames && hasScenario;
      btn.disabled = !enabled;
      if (!hasFrames) {
        btn.title = "No frames to export";
      } else if (!hasScenario) {
        btn.title = "Load a scenario to include with export";
      } else {
        btn.title = `Export ${state.frames.length} frame(s) with scenario`;
      }
      btn.textContent = hasFrames ? `‚¨á Export (${state.frames.length})` : "‚¨á Export";
    }

    function renderJSON(el, data) {
      el.textContent = JSON.stringify(data ?? {}, null, 2);
    }

    // Update Strategic Status panel from AI metadata
    function updateStrategicStatus(metadata, stepInfo = null) {
      const situationEl = document.getElementById("situation-display");
      const formationPill = document.getElementById("enemy-formation-pill");
      const momentumPill = document.getElementById("momentum-pill");
      const prioritiesEl = document.getElementById("priorities-list");
      const decisionsEl = document.getElementById("unit-decisions-list");
      const combatLogEl = document.getElementById("combat-log-list");
      const forceCompEl = document.getElementById("force-composition");

      if (!metadata) {
        if (situationEl) situationEl.textContent = "--";
        if (formationPill) formationPill.textContent = "Formation: --";
        if (momentumPill) momentumPill.textContent = "Momentum: --";
        if (prioritiesEl) prioritiesEl.textContent = "--";
        if (decisionsEl) decisionsEl.textContent = "--";
        if (combatLogEl) combatLogEl.textContent = "--";
        if (forceCompEl) forceCompEl.textContent = "--";
        if (casualtiesEl) casualtiesEl.textContent = "--";
        return;
      }

      const strategic = metadata.strategic || {};

      // Situation analysis
      if (situationEl) {
        situationEl.textContent = strategic.situation_analysis || metadata.reasoning || "--";
      }

      // Enemy formation
      if (formationPill) {
        const formation = strategic.enemy_formation || metadata.forces?.enemy_intent || "--";
        formationPill.textContent = `Formation: ${formation}`;
        formationPill.title = `Enemy Formation: ${formation}`;
      }

      // Momentum
      if (momentumPill) {
        const memory = metadata.memory || {};
        const momentum = memory.momentum !== undefined ? memory.momentum : "--";
        const suggestion = memory.momentum_suggestion || strategic.momentum_suggestion || "";
        let variant = "";
        if (typeof momentum === "number") {
          if (momentum > 0.2) variant = "good";
          else if (momentum < -0.2) variant = "bad";
          else variant = "warn";
        }
        momentumPill.textContent = `Momentum: ${typeof momentum === "number" ? momentum.toFixed(2) : momentum}`;
        momentumPill.title = `${suggestion}`;
        momentumPill.classList.remove("good", "bad", "warn");
        if (variant) momentumPill.classList.add(variant);
      }

      // Force Composition
      if (forceCompEl) {
        const forces = metadata.forces || {};
        const allyCounts = forces.ally_counts || metadata.units_by_role || {};
        const enemyCounts = forces.enemy_counts || {};
        const enemyIntent = forces.enemy_intent || "";
        let html = "";
        if (Object.keys(allyCounts).length) {
          html += `<div style="margin-bottom:4px;"><strong>Friendly:</strong> ${Object.entries(allyCounts).map(([k, v]) => `${k}: ${v}`).join(" | ")}</div>`;
        }
        if (Object.keys(enemyCounts).length) {
          html += `<div style="margin-bottom:4px;"><strong>Enemy:</strong> ${Object.entries(enemyCounts).map(([k, v]) => `${k}: ${v}`).join(" | ")}</div>`;
        }
        if (enemyIntent) {
          html += `<div style="color:var(--text);"><strong>Enemy intent:</strong> ${enemyIntent}</div>`;
        }
        if (metadata.missing_enemies_count > 0) {
          html += `<div style="color:#eab308;"><strong>Missing hostiles:</strong> ${metadata.missing_enemies_count} unaccounted for</div>`;
        }
        forceCompEl.innerHTML = html || "--";
      }

      // Priorities & Directives
      if (prioritiesEl) {
        const priorities = strategic.priorities || [];
        const directives = strategic.directives || [];
        let html = "";
        if (priorities.length) {
          html += priorities.map((p, i) => `<div style="margin-bottom:3px; padding-left:8px; border-left:2px solid var(--accent);">${i + 1}. ${p}</div>`).join("");
        }
        if (directives.length) {
          html += `<div style="margin-top:6px; padding-top:4px; border-top:1px solid rgba(255,255,255,0.05);">`;
          html += directives.map(d => {
            const modeColor = d.mode === "AGGRESSIVE" ? "#ef4444" : d.mode === "DEFENSIVE" ? "#22c55e" : d.mode === "SUPPORT" ? "#3b82f6" : "var(--muted)";
            return `<div style="margin-bottom:3px; display:flex; gap:6px; align-items:baseline;">
              <span style="font-weight:600; min-width:60px;">${d.role}</span>
              <span style="color:${modeColor}; font-size:10px; font-weight:600;">${d.mode}</span>
              <span style="color:var(--muted); font-size:10px;">${d.priority}</span>
            </div>`;
          }).join("");
          html += `</div>`;
        }
        prioritiesEl.innerHTML = html || "--";
      }

      // Unit Tactical Reasoning
      if (decisionsEl) {
        const reasoning = metadata.tactical_reasoning || {};
        const entries = Object.entries(reasoning);
        if (entries.length) {
          decisionsEl.innerHTML = entries.map(([unitId, info]) => {
            const role = info.role || "";
            const action = info.action_type || "";
            const why = info.reasoning || "";
            const actionColor = action === "SHOOT" ? "#ef4444" : action === "MOVE" ? "#22c55e" : action === "TOGGLE" ? "#eab308" : "var(--muted)";
            return `<div style="margin-bottom:5px; padding:4px 6px; background:rgba(255,255,255,0.03); border-radius:4px; border-left:2px solid ${actionColor};">
              <div style="display:flex; gap:6px; align-items:center; margin-bottom:2px;">
                <span style="color:var(--accent); font-weight:600;">#${unitId}</span>
                <span style="color:var(--muted); font-size:10px;">${role}</span>
                <span style="color:${actionColor}; font-weight:600; font-size:10px;">${action}</span>
              </div>
              <div style="font-size:10px; color:var(--text); line-height:1.3;">${why}</div>
            </div>`;
          }).join("");
        } else {
          decisionsEl.textContent = "--";
        }
      }


      // Combat Log
      if (combatLogEl) {
        const results = stepInfo?.combat?.combat_results || [];
        if (results.length) {
          combatLogEl.innerHTML = results.map(r => {
            const color = r.hit ? "#ef4444" : "var(--muted)";
            return `<div style="margin-bottom:2px; font-size:11px; color:${color};">${r.log}</div>`;
          }).join("");
        } else {
          combatLogEl.textContent = "No combat this turn";
        }
      }
    }

    function updateInjectionStatus(message = null, variant = null) {
      const pill = document.getElementById("injection-status");
      const modalPill = document.getElementById("injection-modal-status");
      if (!state.pendingInjection) {
        setStatus(pill, "No pending injection", "warn");
        setStatus(modalPill, "Not applied", "warn");
        return;
      }
      const modeLabel = state.injectionMode === "persistent" ? "every step" : "next step";
      setStatus(pill, message || `Pending (${modeLabel})`, variant || "good");
      setStatus(modalPill, message || `Pending (${modeLabel})`, variant || "good");
      pill.classList.add("clickable");
    }

    function isScenario(obj) {
      if (!obj || typeof obj !== "object") return false;
      return !!(obj.config && Array.isArray(obj.entities) && Array.isArray(obj.agents));
    }

    function normalizeRecordingUpload(json) {
      if (Array.isArray(json.frames)) return { frames: json.frames, scenario: json.scenario };
      if (Array.isArray(json.turns)) return { frames: json.turns, scenario: json.scenario };
      if (Array.isArray(json)) return { frames: json, scenario: null };
      return null;
    }

    function detectUpload(json) {
      const recording = normalizeRecordingUpload(json);
      if (recording) {
        if (recording.scenario && !isScenario(recording.scenario)) {
          throw new Error("Recording scenario missing required fields");
        }
        return { kind: "recording", frames: recording.frames, scenario: recording.scenario || null };
      }
      if (isScenario(json)) {
        return { kind: "scenario", scenario: json };
      }
      throw new Error("JSON is neither scenario nor recording");
    }

    function loadScenarioUpload(scenario, name) {
      state.scenario = scenario;
      state.scenarioName = name || "scenario.json";
      state.uploadInfo = {
        kind: "scenario",
        name: state.scenarioName,
        detail: summarizeScenario(scenario),
      };
      updateStartButton();
      updateExportButton();
      updateUploadSummary();
      updateForkButton();
    }

    function loadRecordingUpload(frames, scenario, name) {
      state.frames = frames;
      state.recordingScenario = scenario || null;
      state.recordingName = name || "recording.json";
      state.uploadInfo = {
        kind: "recording",
        name: state.recordingName,
        detail: `${frames.length} frames${scenario ? ` ‚Ä¢ ${summarizeScenario(scenario)}` : ""}`,
      };
      if (scenario) {
        state.scenario = scenario;
        state.scenarioName = `${state.recordingName} scenario`;
      }
      state.mode = "replay";
      state.currentIndex = 0;
      setPlaying(false);
      updateTimeline();
      setModePill();
      drawCurrent();
      updateMeta();
      updateStartButton();
      updateExportButton();
      updateUploadSummary();
      updateForkButton();
    }

    function getVictoryForIndex(idx) {
      for (let i = idx; i >= 0; i--) {
        const frame = state.frames[i];
        const victory = frame?.step_info?.victory;
        if (victory) return victory;
      }
      return null;
    }

    function formatVictory(victory) {
      if (!victory) return "Victory: ‚Äî";
      const result = victory.result || "IN_PROGRESS";
      const winner = victory.winner || "‚Äî";
      const reason = victory.reason || "";
      return `Victory: ${result}${winner !== "‚Äî" ? ` (${winner})` : ""}${reason ? ` ‚Äî ${reason}` : ""}`;
    }

    function getInjectionTemplate() {
      return JSON.stringify({ blue: {}, red: {} }, null, 2);
    }

    function updateUploadSummary() {
      const summaryBtn = document.getElementById("upload-summary");
      const typeDot = document.getElementById("upload-type-dot");
      const clearBtn = document.getElementById("upload-clear-btn");
      const empty = document.getElementById("upload-empty");
      const loaded = document.getElementById("upload-loaded");
      const detailEl = document.getElementById("upload-detail-text");
      if (!state.uploadInfo) {
        summaryBtn.style.display = "none";
        clearBtn.style.display = "none";
        empty.style.display = "block";
        loaded.style.display = "none";
        typeDot.className = "type-dot";
        return;
      }
      const { name, kind, detail } = state.uploadInfo;
      summaryBtn.textContent = name;
      summaryBtn.style.display = "inline-flex";
      summaryBtn.disabled = kind !== "scenario" && !state.recordingScenario;
      summaryBtn.title = kind === "scenario" ? "View scenario JSON" : state.recordingScenario ? "View recording scenario JSON" : "No scenario found";
      detailEl.textContent = detail;
      loaded.style.display = "flex";
      empty.style.display = "none";
      typeDot.className = `type-dot ${kind}`;
      typeDot.title = kind === "recording" ? "Recording" : "Scenario";
      clearBtn.style.display = "inline-flex";
    }

    const modal = document.getElementById("scenario-modal");
    const modalEditor = document.getElementById("scenario-modal-editor");
    const modalLabel = document.getElementById("scenario-modal-label");
    const modalMeta = document.getElementById("scenario-modal-meta");
    const modalStatus = document.getElementById("scenario-modal-status");
    let currentScenarioSource = null; // "scenario" | "recording"

    const frameModal = document.getElementById("frame-detail-modal");
    const frameModalEditor = document.getElementById("frame-modal-editor");
    const frameModalLabel = document.getElementById("frame-modal-label");
    const frameModalMeta = document.getElementById("frame-modal-meta");
    const entityModal = document.getElementById("entity-modal");
    const entityModalBody = document.getElementById("entity-modal-body");
    const entityModalTitle = document.getElementById("entity-modal-title");

    let lastLayout = null;
    let lastFrame = null;

    function setModalStatus(text, variant = "warn") {
      if (!modalStatus) return;
      modalStatus.textContent = text;
      modalStatus.classList.remove("good", "bad", "warn");
      modalStatus.classList.add(variant);
    }

    function openScenarioModal(source) {
      const data = source === "recording" ? state.recordingScenario : state.scenario;
      if (!data) {
        alert("No scenario loaded for this source.");
        return;
      }
      currentScenarioSource = source;
      modal.classList.add("open");
      modalLabel.textContent = source === "recording" ? "Recording Scenario JSON" : "Game Scenario JSON";
      const filename = source === "recording" ? (state.recordingName || "recording.json") : (state.scenarioName || "scenario.json");
      modalMeta.textContent = `${filename} ‚Ä¢ editable`;
      modalEditor.value = JSON.stringify(data, null, 2);
      setModalStatus("Ready to edit", "warn");
    }

    function closeScenarioModal() {
      modal.classList.remove("open");
      currentScenarioSource = null;
    }

    function saveScenarioFromEditor(useAsLive = false) {
      if (!currentScenarioSource) return;
      let parsed;
      try {
        parsed = JSON.parse(modalEditor.value);
      } catch (err) {
        setModalStatus("Invalid JSON: " + err.message, "bad");
        return;
      }
      state.scenario = parsed;
      if (currentScenarioSource === "recording") state.recordingScenario = parsed;
      if (state.uploadInfo?.kind === "scenario") {
        state.uploadInfo.detail = summarizeScenario(state.scenario);
      } else if (state.uploadInfo?.kind === "recording" && state.recordingScenario) {
        state.uploadInfo.detail = `${state.frames.length} frames ‚Ä¢ ${summarizeScenario(state.recordingScenario)}`;
      }
      setModalStatus("Scenario updated", "good");
      updateStartButton();
      updateExportButton();
      updateUploadSummary();
    }

    function openFrameModal(label, data) {
      frameModalLabel.textContent = label;
      frameModalMeta.textContent = "Read only";
      frameModalEditor.value = JSON.stringify(data ?? {}, null, 2);
      frameModal.classList.add("open");
    }

    function renderEntityDetails(entity, frame) {
      const chips = [];
      const add = (label, value) => chips.push(`<div class="entity-chip"><span class="label">${label}</span><div>${value}</div></div>`);
      const pos = entity.position || entity.pos || [0, 0];
      add("ID", `#${entity.id}`);
      add("Team", entity.team || "‚Äî");
      add("Kind", entity.kind || "‚Äî");
      add("Alive", entity.alive === false ? "No" : "Yes");
      add("Position", `${pos[0]}, ${pos[1]}`);
      if (entity.missiles !== undefined) add("Missiles", entity.missiles);
      if (entity.radar_range !== undefined) add("Radar range", entity.radar_range);
      if (entity.active_radar !== undefined) add("Active radar", entity.active_radar);
      if (entity.cooldown_remaining !== undefined || entity.cooldown_steps !== undefined) {
        add("Cooldown", `${entity.cooldown_remaining ?? 0} / ${entity.cooldown_steps ?? entity.cooldown_remaining ?? 0}`);
      }
      const action = (frame.actions || []).find(a => a.entity_id === entity.id);
      let actionHtml = "";
      if (action) {
        const label = action.label || action.type || "Action";
        let extra = "";
        if (action.params?.target_id) {
          const targetId = action.params.target_id;
          const hitProbs = buildHitProbabilityMap(frame);
          const prob = hitProbs[`${entity.id}-${targetId}`];
          const probText = typeof prob === "number" ? `${Math.round(prob * 100)}%` : "‚Äî";
          extra = `<div style="margin-top:6px;color:var(--muted);font-size:13px;">Target: #${targetId} ‚Ä¢ Hit prob: ${probText}</div>`;
        }
        actionHtml = `<div class="entity-action"><span class="label">Current action</span><div>${label}</div>${extra}</div>`;
      }
      entityModalBody.innerHTML = `
        <div class="entity-grid">
          ${chips.join("")}
        </div>
        ${actionHtml}
      `;
    }

    function openEntityModal(entity, frame) {
      entityModalTitle.textContent = `${entity.kind || "Entity"} #${entity.id}`;
      renderEntityDetails(entity, frame);
      entityModal.classList.add("open");
    }

    // ----------- Connection -----------
    async function pingBackend() {
      try {
        await fetchJson("/status");
        state.connected = true;
        setStatus(document.getElementById("connection-status"), "Connected", "good");
      } catch (err) {
        console.error(err);
        state.connected = false;
        setStatus(document.getElementById("connection-status"), "Disconnected", "bad");
      }
    }

    async function pingBackendWithRetry(retries = 1, delayMs = 800) {
      const pill = document.getElementById("connection-status");
      setStatus(pill, "Checking...", "warn");
      try {
        await pingBackend();
      } catch (err) {
        if (retries > 0) {
          setTimeout(() => pingBackendWithRetry(retries - 1, delayMs), delayMs);
        }
      }
    }

    // ----------- File helpers -----------
    function attachDrop(zone, input, onData) {
      zone.addEventListener("click", e => {
        // Ignore clicks on the loaded summary/clear area
        if (e.target.closest(".upload-loaded") || e.target.closest(".upload-name") || e.target.closest(".icon-btn")) return;
        input.click();
      });
      ["dragenter", "dragover"].forEach(evt =>
        zone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); zone.classList.add("drag"); })
      );
      ["dragleave", "drop"].forEach(evt =>
        zone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); zone.classList.remove("drag"); })
      );
      zone.addEventListener("drop", e => {
        if (e.dataTransfer.files.length) input.files = e.dataTransfer.files;
        input.dispatchEvent(new Event("change"));
      });
      input.addEventListener("change", async () => {
        if (!input.files.length) return;
        const text = await input.files[0].text();
        try {
          const json = JSON.parse(text);
          onData(json, input.files[0].name);
        } catch (err) {
          alert("Invalid JSON file");
        }
        input.value = "";
      });
    }

    attachDrop(
      document.getElementById("upload-drop"),
      document.getElementById("upload-file"),
      (json, name) => {
        try {
          const detected = detectUpload(json);
          if (detected.kind === "scenario") {
            loadScenarioUpload(detected.scenario, name);
          } else {
            loadRecordingUpload(detected.frames, detected.scenario, name);
          }
        } catch (err) {
          alert(err.message);
        }
      }
    );

    // ----------- Human vs Agent Turn Management -----------

    // Check if current scenario has a human agent
    function isHumanVsAgentGame() {
      const agents = state.scenario?.agents || [];
      return agents.some(a => a.type === "human");
    }

    // Get the team controlled by human
    function getHumanTeam() {
      const agents = state.scenario?.agents || [];
      const human = agents.find(a => a.type === "human");
      return human?.team || "BLUE";
    }

    // Start human turn - delegates to the main startHumanTurn defined above
    // (removed duplicate - see main definition above)

    // Show/hide the Your Actions sidebar panel
    function showYourActionsPanel(show) {
      const panel = document.getElementById("your-actions-panel");
      if (!panel) return;
      panel.style.display = show ? "block" : "none";
    }

    // Populate entity actions using server-validated allowed actions
    async function populateEntityActionsList() {
      const container = document.getElementById("entity-actions-list");
      if (!container) return;

      container.innerHTML = '<div style="color: var(--muted); text-align:center; padding:8px;">Loading actions...</div>';

      try {
        // Fetch current world with allowed actions from server
        const worldData = await fetchJson("/current-world");
        if (!worldData || !worldData.entities) {
          container.innerHTML = '<div style="color: var(--muted);">No data available</div>';
          return;
        }

        const humanTeam = getHumanTeam();
        const entities = worldData.entities || [];
        const allowedMap = worldData.allowed_actions || {};
        const humanEntities = entities.filter(e => e.team === humanTeam && e.alive);

        if (humanEntities.length === 0) {
          container.innerHTML = '<div style="color: var(--muted);">No units available</div>';
          return;
        }

        // Update force summary
        const forceSummary = document.getElementById("force-summary");
        if (forceSummary) {
          const total = entities.filter(e => e.team === humanTeam).length;
          const alive = humanEntities.length;
          const missiles = humanEntities.reduce((s, e) => s + (e.missiles || 0), 0);
          forceSummary.textContent = `Units: ${alive}/${total} alive | Missiles: ${missiles}`;
        }

        let html = '';
        for (const entity of humanEntities) {
          const kind = (entity.kind || entity.type || 'unit').toLowerCase();
          const name = entity.name || `${kind} #${entity.id}`;
          const allowed = allowedMap[String(entity.id)] || allowedMap[entity.id] || [];

          // Build action options from server-validated allowed actions
          let actionOptions = '';
          let hasWait = false;

          for (const action of allowed) {
            const actionType = action.type;
            const params = action.params || {};
            const label = action.label || actionType;

            if (actionType === "WAIT") {
              hasWait = true;
              actionOptions += `<option value="WAIT" selected>WAIT (Hold position)</option>`;
            } else if (actionType === "MOVE") {
              const dir = params.dir || "";
              const arrow = dir === "UP" ? "\u2191" : dir === "DOWN" ? "\u2193" : dir === "RIGHT" ? "\u2192" : dir === "LEFT" ? "\u2190" : "?";
              const dirLabel = dir === "UP" ? "North" : dir === "DOWN" ? "South" : dir === "RIGHT" ? "East" : dir === "LEFT" ? "West" : dir;
              actionOptions += `<option value="MOVE_${dir}">MOVE ${arrow} ${dirLabel}</option>`;
            } else if (actionType === "SHOOT") {
              const targetId = params.target_id;
              // Find target name from all entities
              const target = entities.find(e => e.id === targetId);
              const targetName = target ? (target.name || `#${targetId}`) : `#${targetId}`;
              const targetKind = target ? (target.kind || target.type || "") : "";
              // Calculate distance
              let dist = "";
              if (entity.position && target?.position) {
                const dx = Math.abs(entity.position[0] - target.position[0]);
                const dy = Math.abs(entity.position[1] - target.position[1]);
                const distVal = Math.sqrt(dx * dx + dy * dy).toFixed(1);
                dist = ` (dist: ${distVal})`;
              }
              actionOptions += `<option value="SHOOT_${targetId}">SHOOT ${targetName} ${targetKind}${dist}</option>`;
            } else if (actionType === "TOGGLE") {
              const onOff = params.on ? "ON" : "OFF";
              actionOptions += `<option value="TOGGLE_${onOff}">RADAR ${onOff}</option>`;
            }
          }

          if (!hasWait) {
            actionOptions = `<option value="WAIT" selected>WAIT (Hold position)</option>` + actionOptions;
          }

          // Entity status badges
          let badges = '';
          if (entity.missiles !== null && entity.missiles !== undefined) {
            badges += `<span style="font-size:9px; padding:1px 4px; border-radius:3px; background:${entity.missiles > 0 ? 'rgba(59,130,246,0.2)' : 'rgba(239,68,68,0.2)'}; color:${entity.missiles > 0 ? '#60a5fa' : '#ef4444'};">MSL: ${entity.missiles}</span>`;
          }
          if (entity.radar_on !== null && entity.radar_on !== undefined) {
            badges += ` <span style="font-size:9px; padding:1px 4px; border-radius:3px; background:${entity.radar_on ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)'}; color:${entity.radar_on ? '#22c55e' : '#ef4444'};">RDR: ${entity.radar_on ? 'ON' : 'OFF'}</span>`;
          }
          if (entity.cooldown_remaining > 0) {
            badges += ` <span style="font-size:9px; padding:1px 4px; border-radius:3px; background:rgba(234,179,8,0.2); color:#eab308;">CD: ${entity.cooldown_remaining}</span>`;
          }

          // Color based on entity kind
          const borderColor = kind === 'awacs' ? '#22c55e' : kind === 'sam' ? '#eab308' : kind === 'decoy' ? '#a855f7' : '#3b82f6';

          html += `
            <div class="entity-action-row" style="padding: 8px; margin-bottom: 6px; background: rgba(124,210,255,0.06); border-radius: 8px; border-left: 3px solid ${borderColor};">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                <span style="font-weight: 600; color: var(--accent);">#${entity.id} ${name}</span>
                <span style="font-size: 10px; color: var(--muted);">${kind}</span>
              </div>
              ${badges ? `<div style="margin-bottom: 4px;">${badges}</div>` : ''}
              <select id="action-select-${entity.id}" class="entity-action-select" data-entity-id="${entity.id}" style="width: 100%; padding: 6px; border-radius: 6px; background: #1b2235; border: 1px solid var(--border); color: var(--text); font-size: 11px; cursor: pointer;">
                ${actionOptions}
              </select>
            </div>
          `;
        }

        container.innerHTML = html;

        // Add change listeners
        container.querySelectorAll('.entity-action-select').forEach(select => {
          select.addEventListener('change', () => {
            const entityId = parseInt(select.dataset.entityId);
            updatePendingAction(entityId, select.value);
          });
          // Initialize with default WAIT action
          const entityId = parseInt(select.dataset.entityId);
          updatePendingAction(entityId, select.value);
        });
      } catch (err) {
        console.error("Error loading actions:", err);
        container.innerHTML = `<div style="color: #ef4444;">Failed to load actions: ${err.message}</div>`;
      }
    }

    // Update pending action for an entity based on dropdown selection
    function updatePendingAction(entityId, actionValue) {
      let action = { type: "WAIT" };

      if (actionValue === "WAIT") {
        action = { type: "WAIT" };
      } else if (actionValue.startsWith("MOVE_")) {
        const dir = actionValue.replace("MOVE_", "");
        action = { type: "MOVE", params: { dir } };
      } else if (actionValue.startsWith("SHOOT_")) {
        const targetId = parseInt(actionValue.replace("SHOOT_", ""));
        action = { type: "SHOOT", params: { target_id: targetId } };
      } else if (actionValue === "TOGGLE_ON") {
        action = { type: "TOGGLE", params: { on: true } };
      } else if (actionValue === "TOGGLE_OFF") {
        action = { type: "TOGGLE", params: { on: false } };
      }

      state.pendingHumanActions[entityId] = action;
    }

    // endHumanTurn is defined above (consolidated, no duplicate needed)

    // Show/hide turn indicator
    function showTurnIndicator(show, team = "BLUE") {
      // Update the floating indicator
      const indicator = document.getElementById("turn-indicator");
      if (indicator) {
        if (show) {
          const textEl = indicator.querySelector(".turn-indicator-text");
          if (textEl) {
            textEl.textContent = ` Your Turn (${team})`;
          }
          indicator.style.display = "block";
          indicator.classList.add("visible");
        } else {
          indicator.classList.remove("visible");
          indicator.style.display = "none";
        }
      }

      // Also toggle the inline Next Turn button and status in header
      const nextTurnBtn = document.getElementById("next-turn-btn");
      const statusPill = document.getElementById("human-turn-status");

      if (nextTurnBtn) {
        nextTurnBtn.style.display = show ? "inline-flex" : "none";
      }
      if (statusPill) {
        statusPill.textContent = `Your Turn (${team})`;
        statusPill.style.display = show ? "inline-flex" : "none";
      }
    }

    // Show/hide action panel
    function showActionPanel(show) {
      const panel = document.getElementById("action-panel");
      if (!panel) return;
      if (show) {
        panel.classList.add("visible");
      } else {
        panel.classList.remove("visible");
      }
    }

    // Open action panel for a specific entity
    async function openActionPanelForEntity(entityId) {
      state.selectedEntityId = entityId;
      const panel = document.getElementById("action-panel");
      const entityName = document.getElementById("action-entity-name");
      const entityType = document.getElementById("action-entity-type");
      const actionsGrid = document.getElementById("actions-grid");

      // Get entity from current frame
      const frame = state.frames[state.currentIndex];
      const entities = frame?.entities || frame?.world?.entities || [];
      const entity = entities.find(e => e.id === entityId);

      if (!entity) {
        console.error("Entity not found:", entityId);
        return;
      }

      // Set entity info
      if (entityName) entityName.textContent = entity.name || `Entity #${entityId}`;
      if (entityType) entityType.textContent = entity.type || entity.kind || "Unknown";

      // Clear and populate actions
      if (actionsGrid) {
        actionsGrid.innerHTML = '<div class="loading">Loading actions...</div>';
      }

      showActionPanel(true);

      // Fetch allowed actions from API
      try {
        const actions = await fetchJson(`/allowed-actions/${entityId}`);
        if (actionsGrid) {
          renderActionButtons(entityId, actions, entity);
        }
      } catch (err) {
        console.error("Failed to fetch actions:", err);
        if (actionsGrid) {
          actionsGrid.innerHTML = `<div class="error">Failed to load actions</div>`;
        }
      }
    }

    // Render action buttons in the panel
    function renderActionButtons(entityId, actionsData, entity) {
      const actionsGrid = document.getElementById("actions-grid");
      if (!actionsGrid) return;

      const actions = actionsData.actions || [];

      if (actions.length === 0) {
        actionsGrid.innerHTML = '<div class="no-actions">No actions available</div>';
        return;
      }

      // Build buttons for each action
      const buttons = actions.map(action => {
        const actionType = action.type || "WAIT";
        const params = action.params || {};
        let label = actionType;

        // Format action label
        if (actionType === "MOVE") {
          label = `MOVE ${params.dir || ""}`;
        } else if (actionType === "SHOOT") {
          label = `SHOOT ‚Üí #${params.target_id}`;
        } else if (actionType === "TOGGLE") {
          label = params.on ? "RADAR ON" : "RADAR OFF";
        }

        const actionKey = JSON.stringify(action);
        const isSelected = state.pendingHumanActions[entityId] &&
          JSON.stringify(state.pendingHumanActions[entityId]) === actionKey;

        return `<button class="action-btn ${isSelected ? 'selected' : ''}" 
                        data-action='${actionKey}' 
                        data-entity-id="${entityId}">
                  ${label}
                </button>`;
      }).join("");

      actionsGrid.innerHTML = buttons;

      // Add click handlers
      actionsGrid.querySelectorAll(".action-btn").forEach(btn => {
        btn.addEventListener("click", () => {
          const action = JSON.parse(btn.dataset.action);
          const entId = parseInt(btn.dataset.entityId);

          // Set this as the pending action for this entity
          state.pendingHumanActions[entId] = action;

          // Update button states
          actionsGrid.querySelectorAll(".action-btn").forEach(b => b.classList.remove("selected"));
          btn.classList.add("selected");

          // Update pending actions list
          updatePendingActionsList();
        });
      });
    }

    // Update the pending actions display
    function updatePendingActionsList() {
      const list = document.getElementById("pending-actions-list");
      if (!list) return;

      const entries = Object.entries(state.pendingHumanActions);

      if (entries.length === 0) {
        list.innerHTML = '<div class="no-pending">Click entities to select actions</div>';
        return;
      }

      list.innerHTML = entries.map(([entityId, action]) => {
        const actionType = action.type || "WAIT";
        let label = actionType;
        const params = action.params || {};

        if (actionType === "MOVE") {
          label = `MOVE ${params.dir || ""}`;
        } else if (actionType === "SHOOT") {
          label = `SHOOT ‚Üí #${params.target_id}`;
        } else if (actionType === "TOGGLE") {
          label = params.on ? "RADAR ON" : "RADAR OFF";
        }

        return `<div class="pending-action">
                  <span class="entity-id">#${entityId}</span>
                  <span class="action-label">${label}</span>
                </div>`;
      }).join("");
    }

    // Load default scenario
    async function loadDefaultScenario() {
      try {
        const scenario = await fetchJson("/default-scenario");
        state.scenario = scenario;
        state.scenarioName = "Default Scenario (Human vs AI)";
        state.uploadInfo = {
          kind: "scenario",
          name: state.scenarioName,
          detail: summarizeScenario(scenario),
        };
        updateStartButton();
        updateExportButton();
        updateUploadSummary();
        closeWelcomeModal();
      } catch (err) {
        console.error("Failed to load default scenario:", err);
        alert("Failed to load default scenario: " + err.message);
      }
    }

    // Close welcome modal
    function closeWelcomeModal() {
      const modal = document.getElementById("welcome-modal");
      if (modal) modal.classList.remove("open");
    }

    // ----------- Live play -----------
    async function startLive(worldOverride = null) {
      if (!state.scenario) {
        alert("Load a scenario first.");
        return;
      }
      setStartingRun(true);
      try {
        const payload = { scenario: state.scenario, world: worldOverride };
        await fetchJson("/start", { method: "POST", body: JSON.stringify(payload) });
        // If starting from a prior frame, preserve history up to that frame; otherwise reset
        if (!worldOverride) {
          state.frames = [];
          state.currentIndex = 0;
        } else {
          // Drop the forked frame itself; new frames will replace it
          state.frames = state.frames.slice(0, state.currentIndex);
          state.currentIndex = Math.max(0, state.frames.length - 1);
        }
        state.mode = "live";
        state.victoryInfo = null;

        // Check if this is a human vs agent game
        const isHuman = isHumanVsAgentGame();

        // Only auto-play if NOT human vs agent
        if (!isHuman) {
          setPlaying(true);
        } else {
          setPlaying(false);
        }

        updateInjectionStatus();
        updateTimeline();
        setModePill();
        updateForkButton();

        // Always fetch initial frame (frame 0) to establish world state
        // This is required for the canvas to have something to render
        await stepLive();

        // For human vs agent games, start human turn after first frame is loaded
        if (isHuman && !isFrameDone(state.frames[state.currentIndex])) {
          console.log("üéÆ [GAME START] Initial state loaded (frame 0), starting human turn");
          startHumanTurn();
        } else if (state.playing) {
          loop();
        }
      } catch (err) {
        console.error(err);
        alert("Failed to start game: " + err.message);
      } finally {
        setStartingRun(false);
      }
    }

    async function stepLive() {
      const injection = state.pendingInjection || {};
      console.log("üì§ [STEP] Sending to backend:", {
        hasInjection: !!state.pendingInjection,
        injection: injection
      });

      const frame = await fetchJson("/step", {
        method: "POST",
        body: JSON.stringify({ injections: injection }),
      });

      console.log("üì• [STEP] Received frame:", {
        turn: frame.turn,
        hasActions: !!frame.actions,
        actionCount: frame.actions ? Object.keys(frame.actions).length : 0,
        blueActions: frame.actions?.blue ? Object.keys(frame.actions.blue).length : 0,
        redActions: frame.actions?.red ? Object.keys(frame.actions.red).length : 0,
        done: frame.done,
        combatResults: frame.step_info?.combat?.combat_results?.length || 0,
        fullActions: frame.actions  // Show full actions for debugging
      });

      if (state.pendingInjection && state.injectionMode === "once") {
        state.pendingInjection = null;
        updateInjectionStatus("Applied once; cleared", "warn");
      }
      if (frame.step_info?.victory) state.victoryInfo = frame.step_info.victory;
      state.frames.push(frame);
      state.currentIndex = state.frames.length - 1;
      updateTimeline();
      drawCurrent();
      updateMeta();
      // Update strategic status from action metadata
      const redMeta = frame.action_metadata?.red || frame.action_metadata?.blue || null;
      updateStrategicStatus(redMeta, frame.step_info);
      if (isFrameDone(frame)) {
        setPlaying(false);
        // Try to fetch the terminal world-only frame once
        if (frame.actions || frame.step_info || frame.action_metadata) {
          try {
            const finalFrame = await fetchJson("/step", {
              method: "POST",
              body: JSON.stringify({ injections: {} }),
            });
            state.frames.push(finalFrame);
            state.currentIndex = state.frames.length - 1;
            updateTimeline();
            drawCurrent();
            updateMeta();
          } catch (err) {
            console.warn("Unable to fetch final frame:", err.message);
          }
        }
      }
    }

    function loop() {
      clearTimeout(state.playTimer);
      if (!state.playing) return;
      const frame = state.frames[state.currentIndex];
      if (state.mode === "live" && isFrameDone(frame)) {
        setPlaying(false);
        return;
      }
      const delay = 800 / state.speed;
      state.playTimer = setTimeout(async () => {
        try {
          if (state.mode === "live") {
            await stepLive();
          } else if (state.mode === "replay") {
            advanceReplay();
          }
        } catch (err) {
          console.error(err);
          alert(err.message);
          setPlaying(false);
        }
        if (state.playing) loop();
      }, delay);
    }

    // ----------- Replay -----------
    function advanceReplay() {
      if (!state.frames.length) return;
      if (state.currentIndex < state.frames.length - 1) {
        state.currentIndex += 1;
      } else {
        setPlaying(false);
      }
      updateTimeline();
      drawCurrent();
      updateMeta();
    }

    // ----------- UI binding -----------
    document.getElementById("backend-url").addEventListener("input", e => {
      state.baseUrl = e.target.value.trim().replace(/\/$/, "");
    });
    document.getElementById("connection-status").addEventListener("click", pingBackend);
    document.getElementById("start-btn").addEventListener("click", () => startLive(null));
    document.getElementById("fork-btn").addEventListener("click", () => {
      if (!state.frames.length) return alert("No frame selected to fork from.");
      if (!state.recordingScenario && !state.scenario) {
        return alert("Recording missing scenario. Load a scenario first.");
      }
      if (state.recordingScenario) {
        state.scenario = state.recordingScenario;
        state.scenarioName = state.recordingName ? `${state.recordingName} scenario` : "recording scenario";
        if (state.uploadInfo?.kind === "recording") {
          state.uploadInfo.detail = `${state.frames.length} frames ‚Ä¢ ${summarizeScenario(state.recordingScenario)}`;
        }
        updateStartButton();
        updateExportButton();
        updateUploadSummary();
      }
      const frame = state.frames[state.currentIndex];
      const worldOverride = frame.world
        ? { ...frame.world, game_over: false, winner: null }
        : null;
      startLive(worldOverride);
    });
    document.getElementById("upload-summary").addEventListener("click", e => {
      e.stopPropagation();
      const source = state.uploadInfo?.kind === "recording" ? "recording" : "scenario";
      openScenarioModal(source);
    });
    document.getElementById("upload-clear-btn").addEventListener("click", e => {
      e.stopPropagation();
      setPlaying(false);
      state.frames = [];
      state.currentIndex = 0;
      state.recordingScenario = null;
      state.recordingName = null;
      state.scenario = null;
      state.scenarioName = null;
      state.uploadInfo = null;
      state.victoryInfo = null;
      state.mode = "idle";
      updateTimeline();
      drawCurrent();
      updateMeta();
      setModePill();
      updateStartButton();
      updateExportButton();
      updateUploadSummary();
      updateForkButton();
    });
    document.getElementById("scenario-modal-close").addEventListener("click", closeScenarioModal);
    document.querySelector("#scenario-modal .modal-backdrop").addEventListener("click", closeScenarioModal);
    document.getElementById("scenario-modal-save").addEventListener("click", () => saveScenarioFromEditor(false));
    document.getElementById("play-toggle-btn").addEventListener("click", () => {
      setPlaying(!state.playing);
      if (state.playing) loop();
    });
    document.getElementById("step-btn").addEventListener("click", async () => {
      if (state.mode === "live") await stepLive();
      else advanceReplay();
    });
    document.getElementById("view-select").addEventListener("change", e => {
      state.view = e.target.value;
      drawCurrent();
    });
    document.getElementById("toggle-actions").addEventListener("change", e => {
      state.showActions = e.target.checked;
      drawCurrent();
    });
    document.getElementById("toggle-dead-entities").addEventListener("change", e => {
      state.showDeadEntities = e.target.checked;
      drawCurrent();
    });
    document.getElementById("toggle-radar").addEventListener("change", e => {
      state.showRadar = e.target.checked;
      drawCurrent();
    });
    document.getElementById("toggle-ids").addEventListener("change", e => {
      state.showIds = e.target.checked;
      drawCurrent();
    });
    document.getElementById("toggle-grid-labels").addEventListener("change", e => {
      state.showGridCoords = e.target.checked;
      drawCurrent();
    });
    document.getElementById("timeline").addEventListener("input", e => {
      state.currentIndex = parseInt(e.target.value, 10);
      drawCurrent();
      updateMeta();
    });
    document.getElementById("export-btn").addEventListener("click", () => {
      if (!state.frames.length) return alert("No frames to export.");
      const payload = { source: "wg-control-panel", generated_at: new Date().toISOString(), scenario: state.scenario, frames: state.frames };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "recording.json";
      a.click();
      URL.revokeObjectURL(url);
      updateExportButton();
    });
    document.getElementById("injection-status").addEventListener("click", () => {
      const editor = document.getElementById("injection-modal-editor");
      editor.value = state.pendingInjection ? JSON.stringify(state.pendingInjection, null, 2) : getInjectionTemplate();
      document.querySelectorAll('input[name="injection-mode"]').forEach(r => {
        r.checked = r.value === state.injectionMode;
      });
      document.getElementById("injection-modal").classList.add("open");
    });
    document.getElementById("injection-modal-close").addEventListener("click", () => {
      document.getElementById("injection-modal").classList.remove("open");
    });
    document.querySelector("#injection-modal .modal-backdrop").addEventListener("click", () => {
      document.getElementById("injection-modal").classList.remove("open");
    });
    document.getElementById("apply-injection-btn").addEventListener("click", () => {
      const raw = document.getElementById("injection-modal-editor").value.trim() || getInjectionTemplate();
      try {
        state.pendingInjection = JSON.parse(raw);
        const selected = document.querySelector('input[name="injection-mode"]:checked');
        state.injectionMode = selected ? selected.value : "once";
        updateInjectionStatus(`Pending (${state.injectionMode === "persistent" ? "every step" : "next step"})`, "good");
      } catch (err) {
        alert("Injection must be valid JSON");
      }
    });
    document.getElementById("clear-injection-btn").addEventListener("click", () => {
      state.pendingInjection = null;
      state.injectionMode = "once";
      document.getElementById("injection-modal-editor").value = getInjectionTemplate();
      updateInjectionStatus();
    });
    document.getElementById("frame-modal-close").addEventListener("click", () => frameModal.classList.remove("open"));
    document.querySelector("#frame-detail-modal .modal-backdrop").addEventListener("click", () => frameModal.classList.remove("open"));
    document.getElementById("entity-modal-close").addEventListener("click", () => entityModal.classList.remove("open"));
    document.querySelector("#entity-modal .modal-backdrop").addEventListener("click", () => entityModal.classList.remove("open"));
    canvas.addEventListener("click", e => {
      if (!lastFrame || !lastLayout) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const { originX, originY, gridSize, gridHeight } = lastLayout;
      if (x < originX || y < originY) return;
      const gx = Math.floor((x - originX) / gridSize);
      const gyRaw = Math.floor((y - originY) / gridSize);
      if (gx < 0 || gyRaw < 0) return;
      const gy = gridHeight - 1 - gyRaw;
      const frame = lastFrame;
      const entities = getEntitiesForView(frame);
      const match = entities.find(ent => {
        const pos = ent.position || ent.pos || [0, 0];
        return pos[0] === gx && pos[1] === gy;
      });
      if (match) openEntityModal(match, frame);
    });

    // ----------- Rendering -----------
    function drawGrid(world) {
      const { gridSize, originX, originY, gridWidth, gridHeight } = layoutCanvas(world);
      const boardWidth = gridWidth * gridSize;
      const boardHeight = gridHeight * gridSize;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      // Board background
      ctx.fillStyle = "rgba(255,255,255,0.04)";
      ctx.fillRect(originX, originY, boardWidth, boardHeight);
      // Grid lines
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 1;
      for (let x = 0; x <= gridWidth; x++) {
        ctx.beginPath();
        ctx.moveTo(originX + x * gridSize + 0.5, originY);
        ctx.lineTo(originX + x * gridSize + 0.5, originY + boardHeight);
        ctx.stroke();
      }
      for (let y = 0; y <= gridHeight; y++) {
        ctx.beginPath();
        ctx.moveTo(originX, originY + y * gridSize + 0.5);
        ctx.lineTo(originX + boardWidth, originY + y * gridSize + 0.5);
        ctx.stroke();
      }
      // Border
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      ctx.strokeRect(originX, originY, boardWidth, boardHeight);
      ctx.restore();
      return { gridSize, originX, originY };
    }

    function drawGridCoordinates(frame, helpers) {
      if (!state.showGridCoords) return;
      const world = frame.world;
      const gridWidth = world.grid.width;
      const gridHeight = world.grid.height;
      const { gridSize, originX, originY } = helpers;
      const entities = frame.entities || world.entities || [];
      const occupied = new Set();
      for (const ent of entities) {
        const pos = ent.position || ent.pos;
        if (!pos || pos.length < 2) continue;
        occupied.add(`${pos[0]},${pos[1]}`);
      }
      ctx.save();
      const fontSize = Math.max(9, Math.min(12, Math.round(gridSize * 0.35)));
      ctx.font = `600 ${fontSize}px Inter, sans-serif`;
      ctx.fillStyle = "rgba(255,255,255,0.42)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (let x = 0; x < gridWidth; x++) {
        for (let y = 0; y < gridHeight; y++) {
          if (occupied.has(`${x},${y}`)) continue;
          const cx = originX + x * gridSize + gridSize / 2;
          const cy = originY + (gridHeight - y - 1) * gridSize + gridSize / 2;
          ctx.fillText(`${x},${y}`, cx, cy);
        }
      }
      ctx.restore();
    }

    function glyphAircraft(cx, cy, size, color) {
      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(cx, cy - size * 0.6);
      ctx.lineTo(cx - size * 0.25, cy + size * 0.35);
      ctx.lineTo(cx + size * 0.25, cy + size * 0.35);
      ctx.closePath();
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(cx - size * 0.6, cy);
      ctx.lineTo(cx + size * 0.6, cy);
      ctx.stroke();
      ctx.restore();
    }

    function glyphAwacs(cx, cy, size, color) {
      ctx.save();
      glyphAircraft(cx, cy, size, color);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(cx, cy - size * 0.45, size * 0.35, size * 0.12, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function glyphSam(cx, cy, size, color, isOn, cooldownInfo) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      // Base
      ctx.beginPath();
      ctx.moveTo(cx - size * 0.35, cy + size * 0.35);
      ctx.lineTo(cx + size * 0.35, cy + size * 0.35);
      ctx.stroke();
      // Mast
      ctx.beginPath();
      ctx.moveTo(cx, cy + size * 0.35);
      ctx.lineTo(cx, cy);
      ctx.stroke();
      // Launch rails
      ctx.lineWidth = 3;
      ctx.strokeStyle = isOn ? color : "#8b93a5";
      ctx.beginPath();
      ctx.moveTo(cx - size * 0.25, cy + size * 0.15);
      ctx.lineTo(cx - size * 0.25, cy - size * 0.3);
      ctx.moveTo(cx + size * 0.25, cy + size * 0.15);
      ctx.lineTo(cx + size * 0.25, cy - size * 0.3);
      ctx.stroke();
      // Cooldown ring
      if (cooldownInfo && cooldownInfo.total > 0 && cooldownInfo.remaining > 0) {
        const r = size * 0.55;
        ctx.strokeStyle = "#ffb36a";
        ctx.lineWidth = 3;
        const prog = 1.0 - cooldownInfo.remaining / cooldownInfo.total;
        ctx.beginPath();
        ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + prog * 2 * Math.PI);
        ctx.stroke();
      }
      ctx.restore();
    }

    function glyphDecoy(cx, cy, size, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, size * 0.35, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(cx - size * 0.25, cy - size * 0.25);
      ctx.lineTo(cx + size * 0.25, cy + size * 0.25);
      ctx.moveTo(cx + size * 0.25, cy - size * 0.25);
      ctx.lineTo(cx - size * 0.25, cy + size * 0.25);
      ctx.stroke();
      ctx.restore();
    }

    function drawRadar(cx, cy, cellSize, range, color) {
      const radius = range * cellSize;
      ctx.save();
      ctx.strokeStyle = color === "red" ? "rgba(255,123,123,0.28)" : "rgba(124,210,255,0.28)";
      ctx.fillStyle = color === "red" ? "rgba(255,123,123,0.10)" : "rgba(124,210,255,0.10)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function getEntitiesForView(frame) {
      const world = frame.world;
      const entities = frame.entities || world.entities || [];
      let filtered = entities;
      if (state.view !== "god") {
        const team = state.view.toUpperCase();
        const obs = frame.observations?.[state.view] || {};
        const visibleEnemyIds = new Set(obs.visible_enemy_ids || []);
        const obsById = {};
        (obs.entities || []).forEach(o => { obsById[o.entity_id] = o; });

        filtered = entities
          .filter(ent => ent.team === team || visibleEnemyIds.has(ent.id))
          .map(ent => {
            if (ent.team === team) return ent;
            const override = obsById[ent.id];
            if (override) {
              return {
                ...ent,
                position: override.position || ent.position || ent.pos,
                kind: override.kind || ent.kind,
              };
            }
            return ent;
          });
      }

      if (!state.showDeadEntities) {
        filtered = filtered.filter(ent => ent.alive !== false);
      }
      return filtered;
    }

    function drawEntities(frame, helpers) {
      const world = frame.world;
      const { gridSize, originX, originY } = helpers;
      const entities = getEntitiesForView(frame);
      const baseRadius = Math.max(20, Math.min(36, gridSize * 0.9));

      for (const entity of entities) {
        const pos = entity.position || entity.pos || [0, 0];
        const [x, y] = pos;
        const px = originX + x * gridSize;
        const py = originY + (world.grid.height - y - 1) * gridSize;
        const cx = px + gridSize / 2;
        const cy = py + gridSize / 2;
        const color = entity.team === "BLUE" ? "#79a6ff" : "#ff7b7b";
        const isDead = entity.alive === false;
        const glyphRadius = isDead ? Math.max(12, baseRadius * 0.6) : baseRadius;
        const glyphColor = isDead
          ? entity.team === "BLUE"
            ? "rgba(121,166,255,0.45)"
            : "rgba(255,123,123,0.45)"
          : color;

        const kind = (entity.kind || "").toLowerCase();
        const radarOn = entity.radar_on === undefined ? true : !!entity.radar_on;
        const activeRadar = entity.active_radar ?? entity.radar_range ?? 0;
        if (state.showRadar && activeRadar > 0 && (kind !== "sam" || radarOn)) {
          drawRadar(cx, cy, gridSize, activeRadar, entity.team === "RED" ? "red" : "blue");
        }

        ctx.save();
        if (isDead) ctx.globalAlpha = 0.65;

        if (kind === "awacs") glyphAwacs(cx, cy, glyphRadius, glyphColor);
        else if (kind === "sam") {
          const cooldownInfo = {
            remaining: entity.cooldown_remaining || 0,
            total: entity.cooldown_steps || entity.cooldown_remaining || 0,
          };
          glyphSam(cx, cy, glyphRadius, glyphColor, radarOn, cooldownInfo);
        }
        else if (kind === "decoy") glyphDecoy(cx, cy, glyphRadius, glyphColor);
        else glyphAircraft(cx, cy, glyphRadius, glyphColor);
        ctx.restore();

        if (state.showIds) {
          // Draw ID with background for legibility
          const idText = `#${entity.id}`;
          const idW = ctx.measureText(idText).width;

          ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
          ctx.fillRect(px + 2, py + 2, idW + 4, 14);

          ctx.fillStyle = "#f8fafc";
          ctx.font = "bold 11px Inter, sans-serif";
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          ctx.fillText(idText, px + 4, py + 4);

          // Draw type indicator (A, S, D, F)
          let labelChar = "";
          if (kind === "awacs") labelChar = "A";
          else if (kind === "sam") labelChar = "S";
          else if (kind === "decoy") labelChar = "D";
          else if (kind === "aircraft" || kind === "fighter") labelChar = "F";

          if (labelChar) {
            ctx.save();
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.font = "bold 14px Inter, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = "rgba(0,0,0,0.8)";
            ctx.shadowBlur = 4;
            ctx.fillText(labelChar, cx, cy);
            ctx.restore();
          }

          if (entity.can_shoot && entity.missiles !== undefined) {
            // Draw missile count with background for legibility at BOTTOM
            const mText = `M${entity.missiles}`;
            ctx.font = "bold 11px Inter, sans-serif";
            const mW = ctx.measureText(mText).width;
            const mH = 13;

            ctx.save();
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";

            // Background pill centered at bottom
            ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
            // x: center - half_width - padding, y: bottom - height - padding
            ctx.fillRect(cx - mW / 2 - 2, py + gridSize - 2 - mH, mW + 4, mH);

            ctx.fillStyle = "#f8fafc";
            ctx.fillText(mText, cx, py + gridSize - 4);
            ctx.restore();
          }
        }

        if (!entity.alive) {
          ctx.strokeStyle = "rgba(255,255,255,0.6)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cx - glyphRadius * 0.5, cy - glyphRadius * 0.5);
          ctx.lineTo(cx + glyphRadius * 0.5, cy + glyphRadius * 0.5);
          ctx.moveTo(cx + glyphRadius * 0.5, cy - glyphRadius * 0.5);
          ctx.lineTo(cx - glyphRadius * 0.5, cy + glyphRadius * 0.5);
          ctx.stroke();
        }
      }
    }

    function buildHitProbabilityMap(frame) {
      const results = frame?.step_info?.combat?.combat_results;
      if (!Array.isArray(results)) return {};
      const map = {};
      for (const res of results) {
        const attacker = res?.attacker_id;
        const target = res?.target_id;
        const prob = res?.hit_probability;
        if (Number.isInteger(attacker) && Number.isInteger(target) && typeof prob === "number") {
          map[`${attacker}-${target}`] = prob;
        }
      }
      return map;
    }

    function drawHitProbabilityLabel(x, y, text, color) {
      const padding = 4;
      const font = "bold 11px Inter, sans-serif";
      ctx.save();
      ctx.font = font;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const metrics = ctx.measureText(text);
      const w = metrics.width + padding * 2;
      const h = 16;
      ctx.fillStyle = "rgba(8,12,20,0.86)";
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.lineWidth = 1;
      ctx.fillRect(x - w / 2, y - h / 2, w, h);
      ctx.strokeRect(x - w / 2, y - h / 2, w, h);
      ctx.fillStyle = color;
      ctx.fillText(text, x, y + 0.5);
      ctx.restore();
    }

    function drawActions(frame, helpers) {
      if (!state.showActions) return;
      const actions = frame.actions || [];
      const world = frame.world;
      const entities = frame.entities || world.entities || [];
      const byId = {};
      entities.forEach(e => { byId[e.id] = e; });
      const hitProbs = buildHitProbabilityMap(frame);
      const { gridSize, originX, originY } = helpers;
      const obs = state.view === "god" ? null : frame.observations?.[state.view] || {};
      const visibleIds = new Set(
        state.view === "god"
          ? []
          : [...(obs.visible_enemy_ids || []), ...(obs.friendly_ids || [])]
      );
      const viewTeam = state.view.toUpperCase();
      // Track reciprocal target pairs so we can offset overlapping lines
      const pairCount = {};
      actions.forEach(a => {
        if (!a.params?.target_id) return;
        const aId = a.entity_id;
        const bId = a.params.target_id;
        const key = aId < bId ? `${aId}-${bId}` : `${bId}-${aId}`;
        pairCount[key] = (pairCount[key] || 0) + 1;
      });

      for (const action of actions) {
        const actor = byId[action.entity_id];
        if (!actor) continue;
        const isFriendly = actor.team === viewTeam;
        const isVisible = visibleIds.has(actor.id);
        if (state.view !== "god" && !isFriendly) continue; // hide enemy overlays in team view
        const pos = actor.position || actor.pos || [0, 0];
        const [x, y] = pos;
        const cx = originX + x * gridSize + gridSize / 2;
        const cy = originY + (world.grid.height - y - 1) * gridSize + gridSize / 2;
        const strokeColor = actor.team === "BLUE" ? "rgba(124,210,255,0.9)" : "rgba(255,123,123,0.9)";
        ctx.strokeStyle = strokeColor;
        ctx.fillStyle = strokeColor;
        ctx.lineWidth = 2;
        const type = (action.type || action.label || "").toString();

        if ((action.params && action.params.dir) || /MOVE/.test(type)) {
          const dir = (action.params?.dir || type.split(" ").pop() || "").toString().toUpperCase();
          let dx = 0, dy = 0;
          if (dir === "UP") dy = 1;
          else if (dir === "DOWN") dy = -1;
          else if (dir === "LEFT") dx = -1;
          else if (dir === "RIGHT") dx = 1;
          const tx = cx + dx * gridSize;
          const ty = cy - dy * gridSize;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(tx, ty);
          ctx.stroke();
          drawArrowHead(tx, ty, dx, -dy);
        } else if (action.params && action.params.target_id) {
          const target = byId[action.params.target_id];
          if (target) {
            const tpos = target.position || target.pos || [0, 0];
            const [tx, tyRaw] = tpos;
            let txPx = originX + tx * gridSize + gridSize / 2;
            let tyPx = originY + (world.grid.height - tyRaw - 1) * gridSize + gridSize / 2;
            const hitKey = `${actor.id}-${target.id}`;
            const hitProb = hitProbs[hitKey];
            // If reciprocal edge exists, offset the line a bit to avoid overlap
            const key = actor.id < target.id ? `${actor.id}-${target.id}` : `${target.id}-${actor.id}`;
            const isReciprocal = pairCount[key] >= 2;
            let labelX = null;
            let labelY = null;
            let ox = 0, oy = 0, dx = txPx - cx, dy = tyPx - cy;
            ctx.save();
            ctx.setLineDash([8, 6]);
            if (isReciprocal) {
              const len = Math.hypot(dx, dy) || 1;
              const sign = actor.id < target.id ? 1 : -1;
              const offset = Math.max(14, gridSize * 0.4);
              ox = (-dy / len) * offset * sign;
              oy = (dx / len) * offset * sign;
              const startX = cx;
              const startY = cy;
              const endX = txPx + ox;
              const endY = tyPx + oy;
              const arcOffset = Math.max(gridSize * 0.35, 12);
              const midX = (startX + endX) / 2;
              const midY = (startY + endY) / 2 - arcOffset;
              ctx.beginPath();
              ctx.moveTo(startX, startY);
              ctx.quadraticCurveTo(midX, midY, endX, endY);
              ctx.stroke();
              // Use the curve's final direction for arrowhead
              const ddx = endX - midX;
              const ddy = endY - midY;
              drawArrowHead(endX, endY, ddx, ddy, true);
              labelX = 0.25 * startX + 0.5 * midX + 0.25 * endX;
              labelY = 0.25 * startY + 0.5 * midY + 0.25 * endY;
              ctx.restore();
            } else {
              ctx.beginPath();
              ctx.moveTo(cx + ox, cy + oy);
              ctx.lineTo(txPx + ox, tyPx + oy);
              ctx.stroke();
              drawArrowHead(txPx + ox, tyPx + oy, dx, dy, true);
              labelX = (cx + ox + txPx + ox) / 2;
              labelY = (cy + oy + tyPx + oy) / 2;
            }
            ctx.restore();
            if (labelX !== null && hitProb !== undefined) {
              const pct = `${Math.round(hitProb * 100)}%`;
              drawHitProbabilityLabel(labelX, labelY, pct, strokeColor);
            }
          }
        }
      }
    }

    function drawArrowHead(x, y, dx, dy, normalize = false) {
      if (normalize) {
        const len = Math.hypot(dx, dy) || 1;
        dx /= len; dy /= len;
      }
      const size = 8;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.atan2(dy, dx));
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-size, size * 0.6);
      ctx.lineTo(-size, -size * 0.6);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawCurrent() {
      const frame = state.frames[state.currentIndex];
      if (!frame || !frame.world) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      const helpers = drawGrid(frame.world);
      lastLayout = { ...helpers, gridHeight: frame.world.grid.height };
      lastFrame = frame;
      updateExportButton();
      drawGridCoordinates(frame, helpers);
      drawActions(frame, helpers);
      drawEntities(frame, helpers);
      document.getElementById("timeline").value = state.currentIndex;
      document.getElementById("timeline-label").textContent = `${state.currentIndex} / ${Math.max(state.frames.length - 1, 0)}`;
      const victory = getVictoryForIndex(state.currentIndex) || state.victoryInfo;
      document.getElementById("winner-pill").textContent = formatVictory(victory);
      const tracking = `NoShoot: ${frame.world.turns_without_shooting ?? "?"}, NoMove: ${frame.world.turns_without_movement ?? "?"}`;
      document.getElementById("tracking-pill").textContent = `Tracking: ${tracking}`;
      // Frame detail JSON panels removed from UI
    }
    // Ensure canvas adapts on resize (using latest frame)
    window.addEventListener("resize", () => drawCurrent());

    function layoutCanvas(world) {
      const gridWidth = world.grid.width;
      const gridHeight = world.grid.height;
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      const desired = Math.min(rect.width / gridWidth, rect.height / gridHeight);
      const gridSize = Math.max(24, Math.min(72, Math.floor(desired)));
      const worldWidthPx = gridWidth * gridSize;
      const worldHeightPx = gridHeight * gridSize;
      const originX = Math.max(10, (rect.width - worldWidthPx) / 2);
      const originY = Math.max(10, (rect.height - worldHeightPx) / 2);
      return { gridSize, originX, originY, gridWidth, gridHeight };
    }

    function updateTimeline() {
      const slider = document.getElementById("timeline");
      slider.max = Math.max(state.frames.length - 1, 0);
      slider.value = state.currentIndex;
      document.getElementById("timeline-label").textContent = `${state.currentIndex} / ${slider.max}`;
      updateExportButton();
      updateForkButton();
    }

    function updateMeta() {
      const frame = state.frames[state.currentIndex];
      const pill = document.getElementById("entity-pill");
      if (!frame || !frame.world) {
        pill.textContent = "Entities: ‚Äî";
        return;
      }
      const entities = frame.entities || frame.world.entities || [];
      const alive = entities.filter(e => e.alive !== false).length;
      pill.textContent = `Entities: ${alive}/${entities.length} alive`;
      updateForkButton();
    }

    function setModePill() {
      setStatus(document.getElementById("mode-pill"), state.mode === "live" ? "Live" : state.mode === "replay" ? "Replay" : "Idle", "warn");
      updateStartButton();
      updateExportButton();
    }

    // Init
    updateUploadSummary();
    updateInjectionStatus();
    updatePlayButton();
    updateForkButton();
    setModePill();
    pingBackendWithRetry(2, 800);

    // ----------- Human vs Agent Event Listeners -----------

    // Welcome modal - Start Game button
    document.getElementById("welcome-start-btn")?.addEventListener("click", closeWelcomeModal);
    document.getElementById("welcome-modal")?.querySelector(".modal-backdrop")?.addEventListener("click", closeWelcomeModal);

    // Default scenario button
    document.getElementById("use-default-scenario-btn")?.addEventListener("click", loadDefaultScenario);

    // Action panel buttons
    document.getElementById("action-panel-close")?.addEventListener("click", () => showActionPanel(false));
    document.getElementById("clear-actions-btn")?.addEventListener("click", () => {
      state.pendingHumanActions = {};
      updatePendingActionsList();
      if (state.selectedEntityId) {
        const entityData = state.availableActionsCache[state.selectedEntityId];
        if (entityData) renderActionButtons(entityData);
      }
    });
    document.getElementById("end-turn-btn")?.addEventListener("click", endHumanTurn);

    // Next Turn button in header (main way for user to advance the turn)
    document.getElementById("next-turn-btn")?.addEventListener("click", endHumanTurn);

    // Submit Actions button in sidebar panel
    document.getElementById("submit-actions-btn")?.addEventListener("click", endHumanTurn);

    // Note: Human turn uses simple Next Turn button in header - no entity click interception needed
    // Existing Entity Details modal works fine for viewing entity info

  </script>
</body>

</html>